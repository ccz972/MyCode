{
	// Place your oj_env workspace snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	"cf main": {
		"scope": "cpp",
		"prefix": [
			"cf",
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"#define rep(i, a, b) for (int i(a); i <= b; ++ i ) ",
			"#define dec(i, a, b) for (int i(b); i >= a; -- i ) ",
			"",
			"#ifdef LOCAL",
			"  #include <debugger>",
			"#else",
			"  #define debug(...) 42",
			"#endif",
			"",
			"template <typename T> void chkmax(T &x, T y) { x = max(x, y); }",
			"template <typename T> void chkmin(T &x, T y) { x = min(x, y); }",
			"",
			"void solve() {",
			"  $0",
			"",
			"}",
			"int main() {",
			"  cin.tie(nullptr)->sync_with_stdio(false);",
			"",
			"  int T; cin >> T;",
			"  while (T --) {",
			"    solve();",
			"  }",
			"  return 0;",
			"}",
		],
		"description": "codeforces"
	},
	"multicase main": {
		"scope": "cpp",
		"prefix": [
			"#include",
			"main",
			"multi"
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"#define rep(i, a, b) for (int i(a); i <= b; ++ i ) ",
			"#define dec(i, a, b) for (int i(b); i >= a; -- i ) ",
			"",
			"#ifdef LOCAL",
			"  #include <debugger>",
			"  clock_t start = clock();",
			"#else",
			"  #define debug(...) 42",
			"#endif",
			"",
			"template <typename T> void chkmax(T &x, T y) { x = max(x, y); }",
			"template <typename T> void chkmin(T &x, T y) { x = min(x, y); }",
			"",
			"int main() {",
			"  cin.tie(nullptr)->sync_with_stdio(false);",
			"",
			"  auto solve = [&] () {",
			"    $0",
			"",
			"  };",
			"",
			"  int T; cin >> T;",
			"  while (T --) {",
			"    solve();",
			"  }",
			"#ifdef LOCAL",
			"  clock_t ends = clock();",
			"  // cout << \"\\n\\nRunning Time : \" << (double) (ends - start) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;",
			"#endif",
			"  return 0;",
			"}",
		],
		"description": "multicase main"
	},
	"DEBUG" : {
		"scope": "cpp",
		"prefix": "GG",
		"body": [
			"cout << \"FUCK\\n\";",
			"return 0;",
		],
	},
	"fenwick" : {
		"scope": "cpp",
		"prefix": "fenwick",
		"body": [
			"template <typename T>",
			"class fenwick {",
			" public:",
			"  vector<T> fenw;",
			"  int n;",
			" ",
			"  fenwick(int _n) : n(_n) {",
			"    fenw.resize(n);",
			"  }",
			" ",
			"  void modify(int x, T v) {",
			"    while (x < n) {",
			"      fenw[x] += v;",
			"      x |= (x + 1);",
			"    }",
			"  }",
			" ",
			"  T get(int x) {",
			"    T v{};",
			"    while (x >= 0) {",
			"      v += fenw[x];",
			"      x = (x & (x + 1)) - 1;",
			"    }",
			"    return v;",
			"  }",
			"",
			"  T get(int l, int r) {",
			"    return get(r) - get(l - 1);",
			"  }",
			"",
			"};",
		],
	},
	"singlecase main": {
		"scope": "cpp",
		"prefix": [
			"#include",
			"main",
			"single"
		],
		"body": [
			"#include <bits/stdc++.h>",
			"using namespace std;",
			"using ll = long long;",
			"",
			"#define rep(i, a, b) for (int i(a); i <= b; ++ i ) ",
			"#define dec(i, a, b) for (int i(b); i >= a; -- i ) ",
			"",
			"#ifdef LOCAL",
			"  #include <debugger>",
			"  clock_t start = clock();",
			"#else",
			"  #define debug(...) 42",
			"#endif",
			"",
			"template <typename T> void chkmax(T &x, T y) { x = max(x, y); }",
			"template <typename T> void chkmin(T &x, T y) { x = min(x, y); }",
			"",
			"void solve() {",
			"  $0",
			"",
			"",
			"}",
			"int main() {",
			"  cin.tie(nullptr)->sync_with_stdio(false);",
			"  solve();",
			"#ifdef LOCAL",
			"  clock_t ends = clock();",
			"  // cout << \"\\n\\nRunning Time : \" << (double) (ends - start) / CLOCKS_PER_SEC * 1000 << \"ms\" << endl;",
			"#endif",
			"  return 0;",
			"}",
			"",
		],
		"description": "singlecase main"
	},
	"duipai": {
		"scope": "cpp",
		"prefix": "duipai",
		"body": [
			"int T = 10;",
			"while (T -- ) {",
			"  system(\"data.exe > 1.txt\");",
			"  system(\"mycodename.exe < 1.txt > 2.txt\");",
			"  system(\"ac.exe < 1.txt > 3.txt\");",
			"  if (system(\"fc 2.txt 3.txt\")) {",
			"    cout << \"FUCK\\n\";",
			"    break;",
			"  }",
			"}",
		],
		"description": "duipai"
	},
	"read_n": {
		"scope": "cpp",
		"prefix": "n",
		"body": [
			"int n; cin >> n;\n"
		],
		"description": "read_n"
	},
	"read_n_m": {
		"scope": "cpp",
		"prefix": "nm",
		"body": [
			"int n, m; cin >> n >> m;\n"
		],
		"description": "read_n_m"
	},

	"read_n_k": {
		"scope": "cpp",
		"prefix": "nk",
		"body": [
			"int n, k; cin >> n >> k;\n"
		],
		"description": "read_n_k"
	},

	"read_array": {
		"scope": "cpp",
		"prefix": "a",
		"body": [
			"vector<${0:int}> a(n);",
			"for (auto& x : a) cin >> x;\n"
		],
		"description": "read_array"
	},
	"read_2d_array": {
		"scope": "cpp",
		"prefix": "anm",
		"body": [
			"vector a(n, vector<${0:int}>(m));",
			"for (auto& r : a) {",
			"  for (auto& x : r) cin >> x;",
			"}\n",
		],
		"description": "read_2d_array"
	},
	"read_string": {
		"scope": "cpp",
		"prefix": "s",
		"body": [
			"string ${0:s};",
			"cin >> ${0:s};\n"
		],
		"description": "read_string"
	},
	"read_graph_no_weight": {
		"scope": "cpp",
		"prefix": [
			"son",
		],
		"body": [
			"vector<vector<int>> son(n);",
			"for (int i = 1, u, v; i < ${0:n}; i++ ) {",
			"  cin >> u >> v; u --, v --;",
			"  son[u].push_back(v), son[v].push_back(u);",
			"}\n"
		],
		"description": "read_graph1"
	}, 
	"read_graph_with_weight": {
		"scope": "cpp",
		"prefix": [
			"sonw",
		],
		"body": [
			"vector<vector<pair<int> > > son(n);",
			"for (int i = 1, u, v, w; i < ${0:n}; i++ ) {",
			"  cin >> u >> v >> w; u --, v --;",
			"  son[u].push_back(make_pair(v, w)), son[v].push_back(make_pair(u, w));",
			"}\n"
		],
		"description": "read_graph2"
	}, 
	"for_view": {
		"scope": "cpp",
		"prefix": [
			"for",
			"fori"
		],
		// "body": [
		// 	"for (auto ${1:i} : views::iota(0, ${2:n})) {",
		// 	"  ${0}",
		// 	"}"
		// ],
		"body": [
			"for (int ${1:i} = 0; i < ${2:n}; i ++ ) {",
			"  ${0}",
			"}"
		],
		"description": "read_graph"
	},
	"for_view_ij": {
		"scope": "cpp",
		"prefix": [
			"forij",
		],
		"body": [
			"for(int i = 0; i < n; i ++ ) {",
			"  for(int j = 0; j < m; j ++ ) {",
			"    ${0}",
			"  }",
			"}",
		],
		"description": "for_view_ij"
	},
	"dfs_graph_no_weight": {
		"scope": "cpp",
		"prefix": [
			"dfs",
		],
		"body": [
			"function<void(int, int)> dfs = [&](int u, int fa) {",
			"  for (auto& v : son[u]) if(v != fa) {",
			"    dfs(v, u);",
			"    ${0}",
			"  }",
			"};",
		],
		"description": "dfs_graph1"
	},

	"dfs_graph_with_weight": {
		"scope": "cpp",
		"prefix": [
			"dfsw",
		],
		"body": [
			"function<void(int, int)> dfs = [&](int u, int fa) {",
			"  for (auto& [v, w] : son[u]) if(v != fa) {",
			"    dfs(v, u);",
			"    ${0}",
			"  }",
			"};",
		],
		"description": "dfs_graph2"
	},
	"mod": {
		"scope": "cpp",
		"prefix": [
			"MOD",
			"Z"
		],
		"body": [
			"constexpr ll MOD = ${1|998244353,1e9 + 7|};",
			"",
			"ll norm(ll x) { return (x % MOD + MOD) % MOD; }",
			"template <class T>",
			"T power(T a, ll b, T res = 1) {",
			"  for (; b; b /= 2, (a *= a) %= MOD)",
			"    if (b & 1) (res *= a) %= MOD;",
			"  return res;",
			"}",
			"struct Z {",
			"  ll x;",
			"  Z(ll _x = 0) : x(norm(_x)) {}",
			"  auto operator<=>(const Z &) const = default;",
			"  Z operator-() const { return Z(norm(MOD - x)); }",
			"  Z inv() const { return power(*this, MOD - 2); }",
			"  Z &operator*=(const Z &rhs) { return x = x * rhs.x % MOD, *this; }",
			"  Z &operator+=(const Z &rhs) { return x = norm(x + rhs.x), *this; }",
			"  Z &operator-=(const Z &rhs) { return x = norm(x - rhs.x), *this; }",
			"  Z &operator/=(const Z &rhs) { return *this *= rhs.inv(); }",
			"  Z &operator%=(const ll &rhs) { return x %= rhs, *this; }",
			"  friend Z operator*(Z lhs, const Z &rhs) { return lhs *= rhs; }",
			"  friend Z operator+(Z lhs, const Z &rhs) { return lhs += rhs; }",
			"  friend Z operator-(Z lhs, const Z &rhs) { return lhs -= rhs; }",
			"  friend Z operator/(Z lhs, const Z &rhs) { return lhs /= rhs; }",
			"  friend Z operator%(Z lhs, const ll &rhs) { return lhs %= rhs; }",
			"  friend auto &operator>>(istream &i, Z &z) { return i >> z.x; }",
			"  friend auto &operator<<(ostream &o, const Z &z) { return o << z.x; }",
			"};"
		],
		"description": "mod"
	},

	"SegTree": {
		"scope": "cpp",
		"prefix": "SegTree",
		"body": [
			"constexpr int N = 1E5 + 10;",
			"int a[N];",
			"struct segment_tree {",
			"  struct tree {int tl, tr, val, tag;} t[N << 2];",
			"  #define l(x) t[(x)].tl",
			"  #define r(x) t[(x)].tr",
			"  #define len(x) (r(x) - l(x) + 1)",
			"  #define val(x) t[(x)].val",
			"  #define tag(x) t[(x)].tag",
			"  #define lson k << 1",
			"  #define rson k << 1 | 1",
			"  void pushup(int k) { val(k)=val(lson)+val(rson); }",
			"  void pushdown(int k) { ",
			"    val(lson) += tag(k) * len(lson), val(rson) += tag(k)*len(rson); ",
			"    tag(lson) += tag(k), tag(rson) += tag(k); tag(k) = 0; ",
			"  }",
			"  void build(int k, int l, int r) {",
			"    l(k) = l, r(k) = r;",
			"    if(l == r) {val(k) = a[l]; return;}",
			"    int Mid = (l + r) >> 1;",
			"    build(lson,l,Mid);",
			"    build(rson, Mid + 1, r); ",
			"    pushup(k);",
			"  } ",
			"  void update(int k, int l, int r, int z) {",
			"    if(l(k) >= l && r(k) <= r) { val(k) += z * len(k), tag(k) += z; return; }",
			"    if(l(k) > r || r(k) < l)return;",
			"    pushdown(k);",
			"    update(lson, l, r, z); update(rson, l, r, z);",
			"    pushup(k);",
			"  }",
			"  int query(int k, int l, int r) {",
			"    if(l(k) >= l && r(k) <= r) return val(k);",
			"    if(l(k) > r || r(k) < l) return 0;",
			"    pushdown(k);",
			"    return query(lson, l, r) + query(rson, l, r);",
			"  }",
			"",
			"} T; "
	],
		"description": "Plain SegTree"
	},

	// "SegTree": {
	// 	"scope": "cpp",
	// 	"prefix": "SegTree",
	// 	"body": [
	// 		"struct SegTree {",
	// 		"  ll n;",
	// 		"  vector<int> t;",
	// 		"  SegTree(ll _n) : n(_n), t(2 * n) {}",
	// 		"  void modify(ll p, int v) {",
	// 		"    t[p += n] += v;",
	// 		"    for (p /= 2; p; p /= 2) t[p] = t[2 * p] + t[2 * p + 1];",
	// 		"  }",
	// 		"  int query(ll l, ll r) {",
	// 		"    int res = 0;",
	// 		"    for (l += n, r += n; l < r; l /= 2, r /= 2) {",
	// 		"      if (l & 1) res += t[l++];",
	// 		"      if (r & 1) res += t[--r];",
	// 		"    }",
	// 		"    return res;",
	// 		"  }",
	// 		"};",
	// 	],
	// 	"description": "Plain SegTree"
	// },
	
	"Node SegTree": {
		"scope": "cpp",
		"prefix": "SegTree",
		"body": [
			"struct Node {",
			"  ll v = 0, init = 0;",
			"};",
			"",
			"Node pull(const Node &a, const Node &b) {",
			"  if (!a.init) return b;",
			"  if (!b.init) return a;",
			"  Node c;",
			"  return c;",
			"}",
			"",
			"struct SegTree {",
			"  ll n;",
			"  vector<Node> t;",
			"  SegTree(ll _n) : n(_n), t(2 * n){};",
			"  void modify(ll p, const Node &v) {",
			"    t[p += n] = v;",
			"    for (p /= 2; p; p /= 2) t[p] = pull(t[p * 2], t[p * 2 + 1]);",
			"  }",
			"  Node query(ll l, ll r) {",
			"    Node left, right;",
			"    for (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"      if (l & 1) left = pull(left, t[l++]);",
			"      if (r & 1) right = pull(t[--r], right);",
			"    }",
			"    return pull(left, right);",
			"  }",
			"};",
		],
		"description": "Node SegTree"
	},
	"Lazy SegTree": {
		"scope": "cpp",
		"prefix": "lazy",
		"body": [
			"struct Node {",
			"  ll v = 0;",
			"};",
			"struct Tag {",
			"  ll v = 0;",
			"};",
			"Node pull(const Node& a, const Node& b) { return {max(a.v, b.v)}; }",
			"",
			"Tag pull(const Tag& a, const Tag& b) { return {a.v + b.v}; }",
			"",
			"Node apply_tag(const Node& a, const Tag& b) { return {a.v + b.v}; }",
			"",
			"struct SegTree {",
			"  ll n, h;",
			"  vector<Node> t;",
			"  vector<Tag> lazy;",
			"  SegTree(ll _n) : n(_n), h((ll)log2(n)), t(2 * _n), lazy(2 * _n) {}",
			"  void apply(ll x, const Tag& tag) {",
			"    t[x] = apply_tag(t[x], tag);",
			"    lazy[x] = pull(lazy[x], tag);",
			"  }",
			"  void build(ll l) {",
			"    for (l = (l + n) / 2; l > 0; l /= 2) {",
			"      if (!lazy[l].v) t[l] = pull(t[l * 2], t[2 * l + 1]);",
			"    }",
			"  }",
			"  void push(ll l) {",
			"    for (ll s = h; s > 0; s--) {",
			"      ll i = (l + n) >> s;",
			"      if (lazy[i].v) apply(2 * i, lazy[i]), apply(2 * i + 1, lazy[i]);",
			"      lazy[i] = Tag();",
			"    }",
			"  }",
			"  void modify(ll l, ll r, const Tag& v) {",
			"    push(l), push(r - 1);",
			"    ll l0 = l, r0 = r;",
			"    for (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"      if (l & 1) apply(l++, v);",
			"      if (r & 1) apply(--r, v);",
			"    }",
			"    build(l0), build(r0 - 1);",
			"  }",
			"  Node query(ll l, ll r) {",
			"    push(l), push(r - 1);",
			"    Node left, right;",
			"    for (l += n, r += n; l < r; l /= 2, r /= 2) {",
			"      if (l & 1) left = pull(left, t[l++]);",
			"      if (r & 1) right = pull(t[--r], right);",
			"    }",
			"    return pull(left, right);",
			"  }",
			"};"
		],
		"description": "Lazy SegTree"
	},
	"Persistent SegTree": {
		"scope": "cpp",
		"prefix": [
			"SegTree",
			"persistent"
		],
		"body": [
			"struct Node {",
			"  int lc = 0, rc = 0, p = 0;",
			"};",
			"",
			"struct SegTree {",
			"  vector<Node> t = {{}};  // init all",
			"  SegTree() = default;",
			"  SegTree(int n) { t.reserve(n * 20); }",
			"  int modify(int p, int l, int r, int x, int v) {",
			"    // p: original node, update a[x] -> v",
			"    t.push_back(t[p]);",
			"    int u = (int)t.size() - 1;",
			"    if (r - l == 1) {",
			"      t[u].p = v;",
			"    } else {",
			"      int m = (l + r) / 2;",
			"      if (x < m) {",
			"        t[u].lc = modify(t[p].lc, l, m, x, v);",
			"        t[u].rc = t[p].rc;",
			"      } else {",
			"        t[u].lc = t[p].lc;",
			"        t[u].rc = modify(t[p].rc, m, r, x, v);",
			"      }",
			"      t[u].p = t[t[u].lc].p + t[t[u].rc].p;",
			"    }",
			"    return u;",
			"  }",
			"  int query(int p, int l, int r, int x, int y) {",
			"    // query sum a[x]...a[y-1] rooted at p",
			"    // t[p] holds the info of [l, r)",
			"    if (x <= l && r <= y) return t[p].p;",
			"    int m = (l + r) / 2, res = 0;",
			"    if (x < m) res += query(t[p].lc, l, m, x, y);",
			"    if (y > m) res += query(t[p].rc, m, r, x, y);",
			"    return res;",
			"  }",
			"};",
		],
		"description": "Persistent SegTree"
	},
	"union find": {
		"scope": "cpp",
		"prefix": [
			"p",
			"union"
		],
		"body": [
			"vector<ll> p(n);",
			"iota(p.begin(), p.end(), 0);",
			"function<ll(ll)> find = [&](ll x) { return x == p[x] ? x : (p[x] = find(p[x])); };",
			"auto merge = [&](ll x, ll y) { p[find(x)] = find(y); };",
		],
		"description": "union find"
	},
	"primes": {
		"scope": "cpp",
		"prefix": "prime",
		"body": [
			"vector<int> min_primes(MAX_N), primes;",
			"primes.reserve(1e5);",
			"for (int i = 2; i < MAX_N; i++) {",
			"  if (!min_primes[i]) min_primes[i] = i, primes.push_back(i);",
			"  for (auto& p : primes) {",
			"    if (p * i >= MAX_N) break;",
			"    min_primes[p * i] = p;",
			"    if (i % p == 0) break;",
			"  }",
			"}",
		],
		"description": "linear prime sieve"
	},
	"DSU": {
		"scope": "cpp",
		"prefix": "DSU",
		"body": [
			"struct DSU {",
			"  vector<int> f, siz, rank;",
			"  int cnt; //统计还剩多少个连通块",
			"  DSU(int n) : cnt(n), f(n), rank(n, 0), siz(n, 1) { iota(f.begin(), f.end(), 0); }",
			"  int find(int x) {",
			"    while (x != f[x]) x = f[x] = f[f[x]];",
			"    return x;",
			"  }",
			"  bool same(int x, int y) { return find(x) == find(y); }",
			"  int merge(int x, int y) {",
			"    x = find(x), y = find(y);",
			"    if (x == y) return -1;",
			"    else -- cnt;",
			"    if(rank[x] > rank[y]) swap(x, y);",
			"    siz[y] += siz[x];",
			"    f[x] = y;",
			"    if(rank[x] == rank[y]) rank[y] ++;",
			"    return y;",
			"  }",
			"  int size(int x) { return siz[find(x)]; }",
			"}; //按秩合并 and 路径压缩 ",
			" ",
		],
		"description": "并查集"
	},
	"fac": {
		"scope": "cpp",
		"prefix": [
			"fac",
			"binom"
		],
		"body": [
			"vector<Z> f(MAX_N, 1), rf(MAX_N, 1);",
			"for (int i = 2; i < MAX_N; i++) f[i] = f[i - 1] * i % MOD;",
			"rf[MAX_N - 1] = power(f[MAX_N - 1], MOD - 2);",
			"for (int i = MAX_N - 2; i > 1; i--) rf[i] = rf[i + 1] * (i + 1) % MOD;",
			"auto binom = [&](ll n, ll r) -> Z {",
			"  if (n < 0 || r < 0 || n < r) return 0;",
			"  return f[n] * rf[n - r] * rf[r];",
			"};",
		],
		"description": "factorial"
	},
	"rng mt19937_64": {
		"scope": "cpp",
		"prefix": [
			"rnd",
			"mt19937_64"
		],
		"body": [
			"// mt19937 rnd(random_device{}()); ",
			"mt19937_64 rnd(chrono::steady_clock::now().time_since_epoch().count());",
			"",
		],
		"description": "rnd mt19937_64"
	},
	"compress": {
		"scope": "cpp",
		"prefix": [
			"compress",
		],
		"body": [
			"auto compress = ${0:a};",
			"sort(compress.begin(), compress.end());",
			"compress.erase(unique(compress.begin(), compress.end()), compress.end());",
			"for (auto& x : ${0:a}) x = lower_bound(compress.begin(), compress.end(), x) - compress.begin();",
		],
		"description": "compress"
	},
	"quick io": {
		"scope": "cpp",
		"prefix": [
			"io",
		],
		"body": [
			"namespace io {",
			"constexpr int SIZE = 1 << 16;",
			"char buf[SIZE], *head, *tail;",
			"char get_char() {",
			"  if (head == tail) tail = (head = buf) + fread(buf, 1, SIZE, stdin);",
			"  return *head++;",
			"}",
			"ll read() {",
			"  ll x = 0, f = 1;",
			"  char c = get_char();",
			"  for (; !isdigit(c); c = get_char()) (c == '-') && (f = -1);",
			"  for (; isdigit(c); c = get_char()) x = x * 10 + c - '0';",
			"  return x * f;",
			"}",
			"string read_s() {",
			"  string str;",
			"  char c = get_char();",
			"  while (c == ' ' || c == '\\n' || c == '\\r') c = get_char();",
			"  while (c != ' ' && c != '\\n' && c != '\\r') str += c, c = get_char();",
			"  return str;",
			"}",
			"void print(int x) {",
			"  if (x > 9) print(x / 10);",
			"  putchar(x % 10 | '0');",
			"}",
			"void println(int x) { print(x), putchar('\\n'); }",
			"struct Read {",
			"  Read& operator>>(ll& x) { return x = read(), *this; }",
			"  Read& operator>>(long double& x) { return x = stold(read_s()), *this; }",
			"} in;",
			"}  // namespace io",
		],
		"description": "quick io"
	}
}