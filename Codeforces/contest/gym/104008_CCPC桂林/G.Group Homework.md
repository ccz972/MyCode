## 题意

在树上找到两条简单路径，最大化两条路径上的不被重复经过的点的权值和。



##  SOLUTION

首先两条路径可以分为两种情况，相交和不相交

- 两条路径不相交

    问题转化为断开某一条边，求分开的两个树的最长带权直径的和的最大值
    此时需要求出以每个点为根树的所有儿子的最长链、次长链、次次长链，用 `pair<ll, int> h[u][0/1/2]` 来表示，两维分别表示路径和以及所在的儿子，通过换根 $DP$ 可以解决这个问题。

    对于以某一个点为根的树的直径可以分为两种情况：包不包含根节点。

    对于断开某一条链 `u ->v`，假设 $u$ 是 $v$ 的父亲，其实可以想象成 $u$ 把 $v$ 这个儿子舍弃后的最长直径。 

    不妨设 $u$ 两种情况的最大值为 `dp[u]` ，

    - 包含当前节点的直径

        这个非常容易求出，对于 $u$ ，只需要找到儿子不是 $v$ 的前二大链长，然后加上 $u$ 的权值即可，设这个值为 `g[u]` 。 $v$ 同理。

    - 不包含当前节点的直径

        由于 $v$  是 $u$ 的儿子，那么 $v$ 的子树中不包含 $u$ 的直径可以通过 树形 $DP$ 求出，设这个值为 `F[u]` ；
        下面考虑 $u$ ，如果 $u$ 的父亲 $fa$ 不是 $0$，那么 `dp[u]` 是可以从 `dp[fa]​` 转移过来的； 它还可以从 `F[u]` 中转移而来，由于 `F[u]` 是可能从 $v$ 转移过来，因此我们需要记录 最大和次大， 即 `f[u][0/1]` 。

- 两条路径相交

    首先是个结论，两条路径最多只有一个交点。那么考虑枚举交点 $u$ ，然后找到 $u$ 所有儿子 $v$ 的前 4 长链即可，可以利用 `h[v]` 来解决。

- 11



如果两条路径不相交，相当于对于树上的某一条边断开后求分成的两个图的最长带权直径的和

如果两条路径相交，那么至多有一个交点。考虑枚举每个点为分界点，那么求出这个点的前四个最大带权链的权值和即可。



- 求前四大最长链的时候，只需要维护每个点的最大链和次大链即可，最后枚举所有儿子，然后 **sort** 取前四大

- 求某一条边断开后的两个图最长带权直径，只需要知道在以 $1$ 为根的子树中，某个点的子树的最长带权直径，以及除了该点的子树中的点所构成的最长带权直径。

    考虑某个点的子树中的最长带权直径，可能经过这个点，也可能不经过这个点。

    令 `f[u]` 为在以 $1$ 为根的子树中，$u$ 的子树中的最长带权直径长度，并且此时的直径是由 $u$ 以及经过 $u$ 的两条链构成。

    令`pair<int, in> g[u][0/1]` 为在以 $1$ 为根的子树中，$u$ 的子树中的最长带权直径长度，并且此时的直径是由 不包含 $u$ 的路径(即由 $u$ 的子树中的点)构成。 `g[u][0]` 表示最长直径和这个值所在的儿子的编号， `g[u][1]` 为次长。

    

    令 $dp[u]$ 表示除了点 $u$ 的子树中的点所构成的最长带权直径，那么考虑这个直径的构成方式，两种取个最大值。如果是第一种，那么需要枚举 $u$ 的父亲 $fa$ 的所有的儿子的最长链，然后找到最大和次大且不是 $u$ 的链组成即可；如果是第二种那么就需要在 `g[fa][0]` 和 `g[fa][1]` 中选一个，然后和 `fa` 所选的值 取个 `max` 即可。

    

    如果要求除了某个点的子树中的点所构成的最长带权直径，那么**换根**的时候也分两种情况，分别是该点的父亲所在的

    如果不经过这个点

- 1











2021昆明F