/* Generated by powerful Codeforces Tool
 * Author: nanfeng1997
 * Time: 2022-08-27 22:35:22
**/

#include <bits/stdc++.h>
using namespace std;
typedef long long ll;

#define rep(i, a, b) for (int i(a); i <= b; ++ i)

#ifdef LOCAL
#include <debugger>
#else
#define debug(...) 42
#endif

template <typename T> void chkmax(T &x, T y) { x = max(x, y); }
template <typename T> void chkmin(T &x, T y) { x = min(x, y); }

constexpr int N = 2E5 + 10;

int a[N], b[N];
int mi[N], mx[N];
int nxt[N];
bool vis[N];

void solve() {
  int n; cin >> n;  
  rep (i, 1, n) cin >> a[i], mi[i] = 1E9;
  rep (i, 1, n) cin >> b[i], mx[i] = -1E9;
  
  rep (i, 1, n) {
    int idx = lower_bound(b + 1, b + 1 + n, a[i]) - b;
    mi[i] = b[idx] - a[i];  
    vis[i] = false;
  }

  rep (i, 2, n) {
    if (b[i - 1] < a[i]) {
      vis[i] = true;
    }
  }

  mx[n] = b[n] - a[n];
  nxt[n] = n;
  for (int i = n - 1; i >= 1; i -- ) if (vis[i + 1]) {
    nxt[i] = i;
  } else {
    nxt[i] = nxt[i + 1];
  }

  rep (i, 1, n - 1) {
    mx[i] = b[nxt[i]] - a[i];
  }

  rep (i, 1, n) {
    cout << mi[i] << " \n"[i == n];
  }

  rep (i, 1, n) {
    cout << mx[i] << " \n"[i == n];
  }
  //


  /*
  2 3 5
  7 11 13



  */

  //a + d = b
  //如果d[i]最小，那么要让a[i]匹配和它最接近的d[i],判断其他的是否可以组成原数组
  //判断其他的是否可以组成原数组 就是看排序之后的数组 d 每个都比a大
}

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);
  int T = 1; cin >> T;
  while (T --) solve();
  return 0;
}

/*
 *
 *　　┏┓　　　┏┓+ +
 *　┏┛┻━━━┛┻┓ + +
 *　┃　　　　　　　┃
 *　┃　　　━　　　┃ ++ + + +
 *  ████━████+
 *  ◥██◤　◥██◤ +
 *　┃　　　┻　　　┃
 *　┃　　　　　　　┃ + +
 *　┗━┓　　　┏━┛
 *　　　┃　　　┃ + + + +Code is far away from 　
 *　　　┃　　　┃ + bug with the animal protecting
 *　　　┃　 　 ┗━━━┓ 神兽保佑,代码无bug　
 *　　　┃ 　　　　　　 ┣┓
 *　　  ┃ 　　　　　 　┏┛
 *　    ┗┓┓┏━┳┓┏┛ + + + +
 *　　　　┃┫┫　┃┫┫
 *　　　　┗┻┛　┗┻┛+ + + +
 */
