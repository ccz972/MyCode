/* Generated by powerful Codeforces Tool
 * Author: nanfeng1997
 * Time: 2022-12-01 15:20:01
**/

#include <bits/stdc++.h>
using namespace std;
using ll = long long;

#define pb push_back
#define eb emplace_back
#define maxe max_element
#define mine min_element
#define ay2 array<int, 2>
#define PII pair<int, int>
#define SZ(a) ((int)a.size()) 
#define all(v) v.begin(), v.end()
#define Rep(i, a, b) for (int i(a); i < b; ++ i ) 
#define rep(i, a, b) for (int i(a); i <= b; ++ i ) 
#define dec(i, a, b) for (int i(b); i >= a; -- i ) 

#ifdef LOCAL
  #include <debugger>
#else
  #define debug(...) 42
#endif

template <typename T> void chkmax(T &x, T y) { x = max(x, y); }
template <typename T> void chkmin(T &x, T y) { x = min(x, y); }

// mt19937 rnd(random_device{}()); 
mt19937_64 mrand(chrono::steady_clock::now().time_since_epoch().count());
int rnd(int x) { return mrand() % x;}

constexpr int INF = 0x3f3f3f3f;
constexpr ll INFF = 0x3f3f3f3f3f3f3f3f;
// constexpr int N = 2E5 + 10;
template <typename T>
class fenwick {
 public:
  vector<T> fenw;
  int n;
 
  fenwick(int _n) : n(_n) {
    fenw.resize(n);
  }
 
  void modify(int x, T v) {
    while (x < n) {
      fenw[x] += v;
      x |= (x + 1);
    }
  }
 
  T get(int x) {
    T v{};
    while (x >= 0) {
      v += fenw[x];
      x = (x & (x + 1)) - 1;
    }
    return v;
  }

  T get(int l, int r) {
    return get(r) - get(l - 1);
  }

};

void solve() {
  int n; cin >> n;
  vector<int> a(n + 1);
  priority_queue<pair<int, int> > q;
  // for (auto& x : a) cin >> x, q.push(make_pair(x, i));
  rep(i, 1, n) {
    int x; cin >> x;
    a[i] = x;
    q.push(make_pair(x, i));
  }
  int x; cin >> x;
  fenwick<int> cnt(n + 10);
  fenwick<ll> sum(n + 10);

  set<int> s;
  while (!q.empty() && q.top().first >= x) {
    auto [val, idx] = q.top(); q.pop();
    s.insert(idx);
    cnt.modify(idx, 1);
    sum.modify(idx, val);
  }
  //4    4 2
  while (!q.empty()) {
    auto [val, idx] = q.top(); q.pop();
    ll sumval = sum.get(idx);
    
  }

  // cout << q.top() << "\n";
  
  
  /// 4 4 4 2 4 2 4 4      
  // 4 2 4 3 4
}

constexpr int N = 1E5 + 10;
int a[N];
void solve2() {
  int n; cin >> n;
  rep(i, 1, n) cin >> a[i];
  int x; cin >> x;
  // cout << *max_element(a + 1, a + 1 + n) << "\n";
  // cout << x << "\n";
  if (*max_element(a + 1, a + 1 + n) < x) {
    cout << "1\n"; return;
  }
  if (true) {
    a[0] = a[n + 1] = x;
    n ++;
    int ret = 0;
    int last = x + 100000000;
    for (int i = 0; i <= n; i ++ ) if (a[i] >= x) {
      // debug(i);
      ++ ret;
      int j = i;
      while (j + 1 <= n && a[j + 1] < x) ++ j;
      if (i == j) {
        last = x + 100000000;
        continue;
      }
      j ++;
      if (j > n) break;
      // [i, j]
      int mx = a[i + 1];
      for (int k = i + 1; k < j; k ++ ) {
        chkmax(mx, a[k]);
      }

      if (((mx + a[i]) >= x * 2 || i == 0) && ((mx + a[j]) >= x * 2 || j == n) && ((mx + a[i] + last) >= x * 3 || i == 0)) {
        ++ ret;
        last = mx;
      } else {
        // debug("flag", i, j, ret, mx, last);  
        last = x + 100000000;
      }
      // debug(i, j, ret, mx, last);
      i = j - 1;
    }
    // debug(ret);
    cout << max(1, ret - 2) << "\n";
  }
  if (false) {
    int idx = 0;
    while (idx + 1 <= n && a[idx + 1] < x) ++ idx;
    idx ++;
    int l = idx;

    idx = n + 1;
    while (idx - 1 >= 1 && a[idx - 1] < x) -- idx;
    idx --;
    int r = idx; 

    if (l == r) {
      return cout << "1\n", void();
    }
    int ret = 0;
    int last = x + 100000000;
    for (int i = l; i <= r; i ++ ) if (a[i] >= x) {
      ++ ret;
      int j = i;
      while (j + 1 <= r && a[j + 1] < x) ++ j;
      if (i == j) {
        continue;
      }
      j ++;
      if (j > r) break;
      // [i, j]
      int mx = a[i + 1];
      for (int k = i + 1; k < j; k ++ ) {
        chkmax(mx, a[k]);
      }

      if ((mx + a[i]) >= x * 2 && (mx + a[j]) >= x * 2 && (mx + a[i] + last) >= x * 3) {
        ++ ret;
        last = mx;
      } else {
        last = x + 100000000;
      }
      debug(i, j, ret);
      i = j - 1;
    }
    cout << ret << "\n";
    // 1  5   5  2  |
    //  x | x | 
    
  }  
}


struct segment_tree {
  // int a[N];
  struct tree {int tl, tr, val, tag;} t[N << 2];
  #define l(x) t[(x)].tl
  #define r(x) t[(x)].tr
  #define len(x) (r(x) - l(x) + 1)
  #define val(x) t[(x)].val
  #define tag(x) t[(x)].tag
  #define lson k << 1
  #define rson k << 1 | 1
  void pushup(int k) { val(k)=min(val(lson),val(rson)); }
  void pushdown(int k) { 
    // val(lson) += tag(k) * len(lson), val(rson) += tag(k)*len(rson); 
    val(lson) += (tag(k)), val(rson) += tag(k);
    tag(lson) += tag(k), tag(rson) += tag(k); tag(k) = 0; 
  }
  void build(int k, int l, int r) {
    l(k) = l, r(k) = r;
    if(l == r) {val(k) = 0; return;}
    int Mid = (l + r) >> 1;
    build(lson,l,Mid);
    build(rson, Mid + 1, r); 
    pushup(k);
  } 
  void update(int k, int l, int r, int z) {
    if(l(k) >= l && r(k) <= r) { val(k) += z; tag(k) += z; return; } //val(k) += z * len(k), tag(k) += z; return; }
    if(l(k) > r || r(k) < l)return;
    pushdown(k);
    update(lson, l, r, z); update(rson, l, r, z);
    pushup(k);
  }
  int query(int k, int l, int r) {
    if(l(k) >= l && r(k) <= r) return val(k);
    if(l(k) > r || r(k) < l) return 0;
    pushdown(k);
    return min(query(lson, l, r), query(rson, l, r));
  }

} T; 

void solve3() {
  int n; cin >> n;
  rep(i, 1, n) cin >> a[i];
  int x; cin >> x;
  rep(i, 1, n) a[i] -= x;
  int ans = n;
  for (int i = 2; i <= n; i ++ ) {
    if (a[i] + a[i - 1] < 0 || (a[i] + a[i - 1] + a[i - 2]) < 0) {
      -- ans;
      a[i] = INF;
    }
  }
  cout << ans << "\n";
}

int main() {
  cin.tie(nullptr)->sync_with_stdio(false);

  int T; cin >> T;
  while (T --) {
    solve3();
  }
  return 0;
}

/*
 *
 *　　┏┓　　　┏┓+ +
 *　┏┛┻━━━┛┻┓ + +
 *　┃　　　　　　　┃
 *　┃　　　━　　　┃ ++ + + +
 *  ████━████+
 *  ◥██◤　◥██◤ +
 *　┃　　　┻　　　┃
 *　┃　　　　　　　┃ + +
 *　┗━┓　　　┏━┛
 *　　　┃　　　┃ + + + +Code is far away from 　
 *　　　┃　　　┃ + bug with the animal protecting
 *　　　┃　 　 ┗━━━┓ 神兽保佑,代码无bug　
 *　　　┃ 　　　　　　 ┣┓
 *　　  ┃ 　　　　　 　┏┛
 *　    ┗┓┓┏━┳┓┏┛ + + + +
 *　　　　┃┫┫　┃┫┫
 *　　　　┗┻┛　┗┻┛+ + + +
 */
