### SOLUTION

考虑动态规划，由于对物品有限制，因此可以考虑在最优顺序上进行动态规划.
假设已经选了重量和为 $x$ 的羊放在最上面，现在对于 羊A 和 羊B 我们先选哪个呢？

如果先选 羊$A$ 再选 羊$B$，那么需要满足 $x \le s[A], x + v[A] \le S[B]$，因此 $x \le \min(S[A], s[B] - v[A])$.

如果先选 羊$B$ 再选 羊$A$，那么需要满足 $x \le s[B], x + v[B] \le S[A]$，因此 $x \le \min(S[B], s[A] - v[B])$.

那么如果想选更多重量的羊，并且在 $A$ 和 $B$ 中选，则若先选 $A$ 则需要满足 $\min(S[A], s[B] - v[A]) \ge \min(S[B], s[A] - v[B])$.

这样就可以确定动态规划的最优顺序.

然后考虑动态规划， `dp[i][j]` 表示 前 $i$ 个羊中，选了重量和为 $j$ 的羊，所能获得的最大价值

### CODE

```cpp
#include  <bits/stdc++.h>
using namespace std;
typedef long long ll;

void solve() {
  int n; cin >> n;
  vector<array<int, 3> > a(n); //w s v
  for(int i = 0; i < n; i ++) {
    cin >> a[i][0] >> a[i][1] >> a[i][2];
  }  
  sort(a.begin(), a.end(), [&](array<int, 3>  x, array<int, 3>  y) {
    return min(x[1], y[1] - x[0]) > min(y[1], x[1] - y[0]); //注意排序的时候不能带 = 号，会影响偏序关系
  });
  vector<ll> f(30001, -1e18); // 将第一维压缩掉了
  f[0] = 0; 
  for(int i = 0; i < n; i ++ ) {
    auto nf = f; 
    auto [w, s, v] = a[i];
    for(int j = 0; j <= 10000 ; j ++ )  if(j <= s) {
      f[j + w] = max(f[j + w], nf[j] + v);
    }
  }
  cout << *max_element(f.begin(), f.end());
}

int main() {
  ios::sync_with_stdio(false);
  cin.tie(nullptr);
  int T = 1; //cin >> T;
  while(T --) solve();

  return 0;
}
```

